\chapter{Introduction}

\section{Purpose of the Study}

The main purpose of this thesis is to incorporate the two research areas \mss{}
and \ogs{}. Both areas have individually been the topic of intense research
lately \todo{Citation needed} but very little research exists on how to combine
the two.

In regard to the \mss{} domain this thesis serves as a base for discussion about
\ms{} applications. Specifically the development and operation a set of \mss{} is
explained in detail. Of particular interest is the topic of how to facilitate
the composition of \mss{} and how to deploy a \ms{} application in a modern could
environment.

This thesis also provides a proof of concept that it is possible to develop
\ogs{} using \mss{}. For this purpose a vertical slice prototype is provided to
showcase the necessary fragments that make up a working \og{} in the \ms{}
world. Furthermore this prototype serves as a simple development example of how
to reproduce the development process of \ogs{}. The prototype is intended to
live on after this thesis ends and will continuously improved in the future.

As a secondary objective the usability of the recently very popular
\todo{Citation needed} Procedural Content Generation (PCG) is also discussed in
this thesis.

\section{Theoretical framework}

To curtail the infinite amount of research problems that the topics \ogs{} and
\mss{} offer a theoretical framework can be used. Within the framework the
abstract research problems are translated to research questions that cover the
area of interest sufficiently. According to the research questions hypotheses
can be formulated. The verification of these hypotheses is the final goal of
this thesis.

\subsection{Research Problems and Research Questions}

\subsubsection{Usability of a \ms{} for \ogs{}} 

\paragraph{Research Problem:} The usability of \ms{} suited to develop and
operate an \og{}.

\paragraph{Research Questions:}
\begin{itemize}
  \item Can an \og{} run in a pure \ms{} environment?
  \item Is a \ms{} influenced architecture suitable to design an \og{}?
  \item Is the added complexity during development tolerable?
  \item Is the overhead introduced by \mss{} negligible? 
\end{itemize}

\subsubsection{Deployment and Operation}

\paragraph{Research Problem:} The deployment and operation of a \ms{}
application in a cloud cluster-environment.

\paragraph{Research Questions:}
\begin{itemize}
  \item Which steps are necessary to operate an \og{} in a cluster-environment?
  \item How well do \ogs{} operate in a cluster-environment?
  \item How does a modern container engine assist in building and operating a
  \ms{} driven application?
  \item How can the deployment process be automated?
  \item Which tools exist that help the developer with deployment?
\end{itemize}

\subsubsection{\ms{} Composition}
\paragraph{Research Problem:} The composition of a set of \mss{} to form a coherent
distributed application.

\paragraph{Research Questions:}
\begin{itemize}
  \item What degree of composition is necessary for a \ms{} application to work?
  \item What is the minimal set of static and dynamic information that is needed
  for \ms{} composition?
  \item Which of the common paradigms orchestration and choreography is suited
  better for \ms{} composition?
  \item Which middle-ware is most useful in providing \ms{} composition?
\end{itemize}

\subsubsection{\ms{} Coupling}
\paragraph{Research Problem:} The degree to which \mss{} are semantically
dependent on each other. 

\paragraph{Research Questions:}
\begin{itemize}
  \item How can multiple game features be developed in parallel in different
  \mss{} while preserving the overall application behaviour?
  \item What problems are introduced by coupling game features loosely? 
  \item How does the consistency vs. performance trade-off impact \ogs{}?
  \item What protocols help to reduce service coupling?
  \item Can global static domain information help to reduce \ms{} coupling?
\end{itemize}

\subsubsection{\ms{} Development}
\paragraph{Research Problem:} The development process of a \ms{} application.

\paragraph{Research Questions:}

Development of a \ms{} application:
\begin{itemize}
  \item What separates \ms{} development from regular development?
  \item Which is the minimal number of steps ``from code to cloud''?
  \item Which tools help with \ms{} development?
  \item Which development tools make the development process significantly
  simpler?
\end{itemize}

\subsection{Hypotheses}

The essence of the research problems can be condensed to a set of hypotheses
which correspond with the different research areas. All hypotheses are
verified in the course of this thesis to prove that \mss{} are suited to
build an \og{}. 

\subsubsection{\ogs{} and \mss{} Hypothesis}
It is possible to build an \og{} as a pure \ms{} application by
respecting all seven \ms{} tenets.

\subsubsection{Required Features Hypothesis}
A minimal set of features is required to build a distributed \og{}: Networking,
persistence, serialization, session management and game engine integration.

\subsubsection{Stability and Performance Hypothesis} 
Microservices allow to separate the performance critical real-time game
simulation in regards to computing, bandwidth and latency requirements from the
non time-critical backend functionality of an online game. This allows arbitrary
scaling.

\subsubsection{Simple Development Hypothesis} 
Microservice can make the complicated process of developing online games simpler
by splitting up a complex game domain into small parts that can be developed
independently.

\subsubsection{Reproducibility Hypothesis} 
It is possible to completely prevent initial costs to kick of the development
process using only free/open-source technologies. This allows to reproduce the
development process anywhere at any time.

\section{Significance of the Study}

\mss{} are a very modern approach to realize a Service Oriented Architecture
(SOA). While SOA is not something new and has been in use for more then a decade
\todo{Citation needed} \mss{} are a cutting edge implementation approach to SOA
which has gained popularity only in the recent years. Therefore the theory and
references of how to actually develop and operate such a \ms{} environment are
rather sparse. This thesis servers as a complete reference for all relevant
aspects that have to be taken into account when an application (especially an
\og{}) is developed using \mss{}.

In regards to \ogs{} \mss{} have gained recent popularity. This is due to the
fact that large game development companies (>100 developers) prosecute \ogs{}
with million of player playing at the same time. For these games to scale the
traditional approach of running an \og{} as a monolithic application is not
sufficient. These large companies have large budgets at their disposal to
realize such an \og{}.

But this is not the case for smaller independent game development companies.
Independent companies are not constraint by founders and are therefor the main
driver for innovation in the game industry at the moment. But these  indy-teams don't
have the manpower to develop rich \ogs{} from scratch because the lack of
manpower and financial resources. Also AAA companies don't share their knowledge
about \og{} development to an extent that would allow indies to develop rich
\ogs{}.

Further \og{} development introduces the aspect of distribution within the game
application which is by definition a hard problem \todo{Citation needed}. There
is a lot of existing information on how to cope with asynchronism in game
development\todo{Cite: Gambetta}. However these references are mostly very low
level and leave a lot of responsibility to the developer. This added complexity
is whats holding back creative minds to develop rich \ogs{}. This thesis should
serve as a reference for these independent developers to gain a foothold in the
complex area of \og{} development.

\section{Definitions}

This thesis is aimed to be a direct reference for developing \ogs{} with \mss{}.
Because of this the thesis is of very technical nature. Most concepts developed
in this thesis have a reference implementation in the prototyped developed
during this thesis. 

This section clarifies all terminology that is used to define the concepts
developed in this thesis from a technical point of view.

\subsection{Games and \ogs{}}

Since this thesis is mainly aimed at readers interested in the \ms{} domain it
is mandatory to provide a reasonable introduction in games itself an which
technical requirements they introduce. This helps to frame influence that \ogs{}
can possibly have when built using \mss{}.

\subsubsection{Video Games}

A video game is simply a game played on a digital device e.g. PC, smartphone, or
gaming consoles. The technical details how all of these games are developed
varies greatly depending on various factors like genres, platforms, culture and
so on. Since this thesis does not make any restrictions on the kind of game
under development a common basis for all games must be established. This common
basis is that all games have some audiovisual interface (game client) which
represents the game. 

\subsubsection{The Game Simulation}

The game simulation is a logical abstraction of the game and is responsible to
keep track of the state of game objects as the game progresses. In most games
the game simulation is realized with a physics engine along with code
that steers the simulation.

The game simulation is usually tightly coupled with the rendering process that
presents the game to the player. This is due to the nature of the most basic graphics
libraries like DirectX or OpenGL which are in under the hood used in most video
games. These graphic libraries do the rendering on one process on the computer
(main render thread). There is currently a lot of research conducted on how to
parallelize the render thread \todo{Citation needed} but for the meantime it is
not possible. Therefor we can view the game simulation as a single process bound
by the render thread.

\subsubsection{\ogs{}}
An \og{} can be seen as an extension to a traditional video game. In addition to
the audiovisual representation the player not only interacts with the game
simulation but also with other players playing at the same time at another
location. But in practice the added asynchronism forces a completely different
application design in comparison to traditional single-player games.

\paragraph{Simple \ogs{}}

Simple \ogs{} are single-player games with added multi-player features.
In simple \ogs{} players are responsible to set up game environment. These can
be client-server or peer-to-peer scenarios. In these environments the players
have full control over the game rules.

Usually simple games are of small scale and are played in confined game
sessions. The of the game session is kept locally on the client. Examples of
such simple games are for example Quake, Age of Empires, or Diablo 2. Lately it
has become popular for simple games to provide a matchmaking service that helps
players to find each other for game sessions. This matchmaking functionality is
responsible to initiate the game session on all clients but does not interfere
in a running game session meaning there is no centralized rule enforcement
system in place. Cheating clients are a common problem for this type of games.

\paragraph{Rich \ogs{}}

Rich \ogs{} take the control over the game environment away from the
player. This means that the game is simulated on a server environment and the
game client is a mere representation device. In this setup the game state is
persisted on the server side allowing. This allows for a set of features that
make \ogs{} so interesting. For example an achievement of the player in the game
is recorded by the server and published to all other player playing the game.
This permanent achievements reward the player of a rich online game with a
satisfaction that can be compared with likes on a social media platform. 

Rich \ogs{} only require the player to download the game client or even to just
play the game in the brower which in this case is the audiovisual game client.
That game state of all players is distributed by the server environment to all
players. The clients on the other hand send requests to the server environment
to stimulate the game in some way.

\subsection{Procedural Content Generation}

Procedural Content Generation (PCG) has always been an integral part of game
development and has gained recent popularity because of prominent games that
make extensive use of PCG. Some examples are Minecraft, Terraria, No Mans Sky to
only name a few.

PCG is the process of automatically generating game content. A canonical
example in this regard is vegetation generation. The developer only needs to
supply certain parameters like for example color distribution and branching
factor. The game simulation then 

\subsection{\mss{}}

Microservices are an implementation approach for a service-oriented
architecture\todo{Cite ZIO}. In SOA an application is split into logical units
that each solve one specific task. A problem of traditional SOA is that these
individual services are coupled using a service bus which contains a large
amount of domain knowledge which is used to allow communications between
services. \mss{} reverse this principal and use the smart endpoints - dumb pipes
paradigm. This makes the service bus obsolete. As a result the whole
application is more robust to changes because there is no central processing
unit exposed as a single point of failure.

\subsubsection{\ms{} Tenets}

In the article Microservices tenets: Agile approach to service development and
deployment O.Zimmermann provides seven \ms{} tenets to describe the properties
of \ms{} applications. According to the tenets a correlation between game
specific requirements and \ogs{} can be made. In the course of this thesis the
\ms{} tenets will be used as an indicator to show that \mss{} are suitable for
\og{} applications.

The remainder of this section will give a brief overview over all seven tenets.

\paragraph{Fine-grained Interfaces and Single Responsibility}

Every \ms{} should offer all of its functionality in the form of a fine grained
interface that decouples the service implementation from its interface. This
interface is usually a REST/HTTP and is accessible via a reverse proxy. Each
\ms{} should only have one responsibility in regards to the domain.

\paragraph{Domain-Driven-Design (DDD)}

The responsibility of a \ms{} should be derived from the domain meaning that is
solves exactly one aspect of the domain. If one aspect of the domain would lead
to a large \ms{} it can be an indicator that the granularity of the services
might be wrong.

\paragraph{IDEAL}
\paragraph{Polyglot Programming and Persistence}
\paragraph{Lightweight Containers}
\paragraph{Decentralized Continuous delivery}
\paragraph{DevOps}

\subsubsection{\ms{} Composition}

\subsubsection{\ms{} Deployment}

\subsubsection{\ms{} Development}

\section{Delimitations, Limitations, and Assumptions}




















