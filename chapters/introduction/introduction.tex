\chapter{Introduction}

\section{Purpose of the Study}

The main purpose of this thesis is to incorporate the two research areas \mss{}
and \ogs{}. Both areas have individually been the topic of intense research
lately \todo{Citation needed} but very little research exists on how to combine
the two.

In regard to the \mss{} domain this thesis serves as a base for discussion about
\ms{} applications. Specifically the development and operation a set of \mss{} is
explained in detail. Of particular interest is the topic of how to facilitate
the composition of \mss{} and how to deploy a \ms{} application in a modern could
environment.

This thesis also provides a proof of concept that it is possible to develop
\ogs{} using \mss{}. For this purpose a vertical slice prototype is provided to
showcase the necessary fragments that make up a working \og{} in the \ms{}
world. Furthermore this prototype serves as a simple development example of how
to reproduce the development process of \ogs{}. The prototype is intended to
live on after this thesis ends and will continuously improved in the future.

As a secondary objective the usability of the recently very popular
\todo{Citation needed} Procedural Content Generation (PCG) is also discussed in
this thesis.

\section{Theoretical framework}

To curtail the infinite amount of research problems that the topics \ogs{} and
\mss{} offer a theoretical framework can be used. Within the framework the
abstract research problems are translated to research questions that cover the
area of interest sufficiently. According to the research questions hypotheses
can be formulated. The verification of these hypotheses is the final goal of
this thesis.

\subsection{Research Problems and Research Questions}

\subsubsection{Usability of a \ms{} for \ogs{}} 

\paragraph{Research Problem:} The usability of \ms{} suited to develop and
operate an \og{}.

\paragraph{Research Questions:}
\begin{itemize}
  \item Can an \og{} run in a pure \ms{} environment?
  \item Is a \ms{} influenced architecture suitable to design an \og{}?
  \item Is the added complexity during development tolerable?
  \item Is the overhead introduced by \mss{} negligible? 
\end{itemize}

\subsubsection{Deployment and Operation}

\paragraph{Research Problem:} The deployment and operation of a \ms{}
application in a cloud cluster-environment.

\paragraph{Research Questions:}
\begin{itemize}
  \item Which steps are necessary to operate an \og{} in a cluster-environment?
  \item How well do \ogs{} operate in a cluster-environment?
  \item How does a modern container engine assist in building and operating a
  \ms{} driven application?
  \item How can the deployment process be automated?
  \item Which tools exist that help the developer with deployment?
\end{itemize}

\subsubsection{\ms{} Composition}
\paragraph{Research Problem:} The composition of a set of \mss{} to form a coherent
distributed application.

\paragraph{Research Questions:}
\begin{itemize}
  \item What degree of composition is necessary for a \ms{} application to work?
  \item What is the minimal set of static and dynamic information that is needed
  for \ms{} composition?
  \item Which of the common paradigms orchestration and choreography is suited
  better for \ms{} composition?
  \item Which middle-ware is most useful in providing \ms{} composition?
\end{itemize}

\subsubsection{\ms{} Coupling}
\paragraph{Research Problem:} The degree to which \mss{} are semantically
dependent on each other. 

\paragraph{Research Questions:}
\begin{itemize}
  \item How can multiple game features be developed in parallel in different
  \mss{} while preserving the overall application behaviour?
  \item What problems are introduced by coupling game features loosely? 
  \item How does the consistency vs. performance trade-off impact \ogs{}?
  \item What protocols help to reduce service coupling?
  \item Can global static domain information help to reduce \ms{} coupling?
\end{itemize}

\subsubsection{\ms{} Development}
\paragraph{Research Problem:} The development process of a \ms{} application.

\paragraph{Research Questions:}

Development of a \ms{} application:
\begin{itemize}
  \item What separates \ms{} development from regular development?
  \item Which is the minimal number of steps ``from code to cloud''?
  \item Which tools help with \ms{} development?
  \item Which development tools make the development process significantly
  simpler?
\end{itemize}

\subsection{Hypotheses}

The essence of the research problems can be condensed to a set of hypotheses
which correspond with the different research areas. All hypotheses are
verified in the course of this thesis to prove that \mss{} are suited to
build an \og{}. 

\subsubsection{\ogs{} and \mss{} Hypothesis}
It is possible to build an \og{} as a pure \ms{} application by
respecting all seven \ms{} tenets.

\subsubsection{Required Features Hypothesis}
A minimal set of features is required to build a distributed \og{}: Networking,
persistence, serialization, session management and game engine integration.

\subsubsection{Stability and Performance Hypothesis} 
Microservices allow to separate the performance critical real-time game
simulation in regards to computing, bandwidth and latency requirements from the
non time-critical backend functionality of an online game. This allows arbitrary
scaling.

\subsubsection{Composition Hypothesis}
Code Generation backed by a game meta model is enough information to compose a
set of \mss{} semantically to compound a rich \og{}.

\subsubsection{Deployment Hypothesis}
The deployment process of game a \ms{} application can be simplifies to an
extent that the process can be understood by reading instruction of the size of
one screen.

\subsubsection{Simple Development Hypothesis} 
Microservice can make the complicated process of developing online games simpler
by splitting up a complex game domain into small parts that can be developed
independently.

\subsubsection{Reproducibility Hypothesis} 
It is possible to completely prevent initial costs to kick of the development
process using only free/open-source technologies. This allows to reproduce the
development process anywhere at any time.

\section{Significance of the Study}

\mss{} are a very modern approach to realize a Service Oriented Architecture
(SOA). While SOA is not something new and has been in use for more then a decade
\todo{Citation needed} \mss{} are a cutting edge implementation approach to SOA
which has gained popularity only in the recent years. Therefore the theory and
references of how to actually develop and operate such a \ms{} environment are
rather sparse. This thesis servers as a complete reference for all relevant
aspects that have to be taken into account when an application (especially an
\og{}) is developed using \mss{}.

In regards to \ogs{} \mss{} have gained recent popularity. This is due to the
fact that large game development companies (>100 developers) prosecute \ogs{}
with million of player playing at the same time. For these games to scale the
traditional approach of running an \og{} as a monolithic application is not
sufficient. These large companies have large budgets at their disposal to
realize such an \og{}.

But this is not the case for smaller independent game development companies.
Independent companies are not constraint by founders and are therefor the main
driver for innovation in the game industry at the moment. But these  indy-teams don't
have the manpower to develop rich \ogs{} from scratch because the lack of
manpower and financial resources. Also AAA companies don't share their knowledge
about \og{} development to an extent that would allow indies to develop rich
\ogs{}.

Further \og{} development introduces the aspect of distribution within the game
application which is by definition a hard problem \todo{Citation needed}. There
is a lot of existing information on how to cope with asynchronism in game
development\todo{Cite: Gambetta}. However these references are mostly very low
level and leave a lot of responsibility to the developer. This added complexity
is whats holding back creative minds to develop rich \ogs{}. This thesis should
serve as a reference for these independent developers to gain a foothold in the
complex area of \og{} development.

\section{Definitions}

This thesis is aimed to be a direct reference for developing \ogs{} with \mss{}.
Because of this the thesis is of very technical nature. Most concepts developed
in this thesis have a reference implementation in the prototyped developed
during this thesis. 

This section clarifies all terminology that is used to define the concepts
developed in this thesis from a technical point of view.

\subsection{Games and \ogs{}}

Since this thesis is mainly aimed at readers interested in the \ms{} domain it
is mandatory to provide a reasonable introduction in games itself an which
technical requirements they introduce. This helps to frame influence that \ogs{}
can possibly have when built using \mss{}.

\subsubsection{Video Games}

A video game is simply a game played on a digital device e.g. PC, smartphone, or
gaming consoles. The technical details how all of these games are developed
varies greatly depending on various factors like genres, platforms, culture and
so on. Since this thesis does not make any restrictions on the kind of game
under development a common basis for all games must be established. In this
regard the classical Model-View-Control pattern can be used to identify the
logical artifacts that make up a game: 

\begin{itemize}
  \item \textbf{Model:} The game model artifact holds the game state.
  \item \textbf{View:} The game presentation artifact presents the game state to
  the player.
  \item \textbf{Control:} The game simulation artifact progressed the game
  state and is responsible to accept player input.
\end{itemize}

\paragraph{Game Simulation}

The game simulation can be seen as a logical abstraction of a game. The
simulation is responsible to update the state of all relevant game objects to
progress the state of the game as a whole. In most games the game simulation is
realized with a physics engine along with code that steers the simulation.

\paragraph{Game Presentation}

The game presentation is responsible render the game state on the player
device's screen. Changes in the game state must be made visible by the game
presentation as soon as possible.

The game simulation is usually tightly coupled with the game presentation. This
is due to the nature of the most basic graphics libraries like DirectX or OpenGL
which are foundation of most video games. These graphic libraries typically have
one main render loop. Within this loop the developer gets a chance to update
every game object before it is drawn to the screen. As a consequence the game
simulation cannot be completely separated from the presentation process. More
information on graphics libraries can be found in the book Real-Time
Rendering\cite{RTR3}. Furthermore the web-page of the book provides a
comprehensive selection on related literature and technical examples.

\paragraph{Game Model}

The game model consists of a meta model containing a set of object types and an
instantiation of this meta model which represents the game state. The game
simulation operates upon the game state to progress the game. Static data
like for example audiovisual information for the game presentation is directly
stored in the meta model and can be referenced by the game state.

\paragraph{Game Engines}
All the artifacts of a game as described in the previous three sections are
fairly low level. To relieve the developer from these low level tasks usually
game engines are used. These game engines come with comprehensive editors, tools
and libraries that abstract the complex low level functionality. This allows the
developer to focus the effort on the core parts of the game. 

\subsubsection{\ogs{}}
An \og{} can be seen as an extension to a traditional video game. In addition to
the audiovisual representation the player not only interacts with the game
simulation but also with other players playing at the same time at another
location. But in practice the added asynchronism forces a completely different
application design in comparison to traditional single-player games.

\paragraph{Simple \ogs{}}

Simple \ogs{} are single-player games with added multi-player features.
In simple \ogs{} players are responsible to set up game's multi-player
environment. These can be client-server or peer-to-peer scenarios. In these
environments the players have full control over the game rules.

Usually simple games are of small scale and are played in confined game
sessions. The state of the game session is stored locally on the client.
Examples of such simple games are for example Quake, Age of Empires, or Diablo
2. Lately it has become popular for simple games to provide a matchmaking
service that helps players to find each other for game sessions. This
matchmaking functionality is responsible to initiate the game session on all
clients but does not interfere in a running game session meaning there is no
centralized rule enforcement system in place. Cheating clients are a common
problem for this type of games.

\paragraph{Rich \ogs{}}

Rich \ogs{} take the control over the game environment away from the player.
This means that the game is simulated on a server environment meaning that the
game client is only responsible for the presentation of the game and for sending
inputs to the server but not for simulating the game. In this setup the game
state is persisted on the server side. The persistence of the game state in this
fashion allows for a set of features which really separate \ogs{} from simple
online or offline video games.

Most noticeable is the feature of virtual property. In rich \ogs{} it is usually
possible to gain an advantage when it is player a lot. This gives the player a
sense of power and the motivation to play the game for longer. This can be
compared to the satisfaction that is triggers when a person receives a like on a
social media platform.

Rich \ogs{} are also very comfortable for the players. The players only need to
download the game client to play the game.

\subsection{Procedural Content Generation}

Procedural Content Generation (PCG) has always been an integral part of game
development and has gained recent popularity because of prominent games that
make extensive use of PCG. Some examples are Minecraft, Terraria, No Mans Sky to
only name a few.

PCG is the process of automatically generating game content. A canonical
example in this regard is vegetation generation. The developer only needs to
supply certain parameters like for example color distribution and branching
factor. The game simulation then 

\subsection{\mss{}}

Microservices are an implementation approach for a service-oriented
architecture\todo{Cite ZIO}. In SOA an application is split into logical units
that each solve one specific task. A problem of traditional SOA is that these
individual services are coupled using a service bus which contains a large
amount of domain knowledge which is used to allow communications between
services. \mss{} reverse this principal and use the smart endpoints - dumb pipes
paradigm. This makes the service bus obsolete. As a result the whole
application is more robust to changes because there is no central processing
unit exposed as a single point of failure.

\subsubsection{\ms{} Tenets}

In the article Microservices tenets: Agile approach to service development and
deployment O.Zimmermann provides seven \ms{} tenets to describe the properties
of \ms{} applications. According to the tenets a correlation between game
specific requirements and \ogs{} can be made. In the course of this thesis the
\ms{} tenets will be used as an indicator to show that \mss{} are suitable for
\og{} applications.

The remainder of this section will give a brief overview over all seven tenets.

\paragraph{Fine-grained Interfaces and Single Responsibility}

Every \ms{} should offer all of its functionality in the form of a fine grained
interface that decouples the service implementation from its interface. This
interface is usually a REST/HTTP and is accessible via a reverse proxy. Each
\ms{} should only have one responsibility in regards to the domain. This allows
services to be deployed, changed, replaced and scaled independently.

\paragraph{Domain-Driven-Design (DDD)}

The responsibility of a \ms{} should be derived from the domain concept. Each
service is dedicated to exactly one aspect of the domain. If this aspect is very
extensive it can lead to a large \ms{} which is not desirable. This can be an
indicator that the granularity of the services might be wrong. Granularity is
the most challenging part of DDD\cite{millett2015patterns}.

\paragraph{IDEAL}

The IDEAL tenet is a collection of cloud patterns. These patterns to partially
overlap with several other tenets like single responsibility or decentralized
continuous delivers. None the less this tenet is is a great indicator to
validate that an application respects the major cloud principals. C. Fehling et
al. provides a good overview over the  IDEAL Cloud Application Properties
summarized in this section\cite{fehling2015cloud}.

\subparagraph{Isolated State}
A \ms{} should be stateless meaning that request that the \ms{} fulfils should
be completely confined in itself. This means that \mss{} are not allowed to
store date in-memory between requests. Instead the state should be persisted in
a data storage provided by the cloud e.g. another \ms{}.

\subparagraph{Distribution}
To allow an application to scale, its functionality is spread out among several
different \mss{}. These shards are then deployed in cloud environments which are
large distributed system themselves. \ms{} applications are a natural match for
the distributed nature of cloud environments.

\subparagraph{Elasticity}
Elasticity inquires that the application can be scaled during operation. When
the need of scaling arises it must be possible to add and remove \mss{} without
affecting the stability of the whole system.

\subparagraph{Automated Management}
In order to quickly react to scaling demands or to recover from failure the
management approach to these scenarios should be fully automated.

\subparagraph{Loose Coupling}

The dependencies among \mss{} should be reduced as much as possible. It is not
feasible to reduce dependencies to zero because without any dependencies the
application is not able to work as a whole unit. If the amount of dependencies
is manageable the impact of adding and removing new functionality can be kept
to a minimum.

\paragraph{Polyglot Programming and Persistence}

The polyglot tenet is the main driver when it comes to \ms{} confinement. It
states that a \ms{} has no restriction on storage paradigms and implementation
details. As a consequence each \ms{} can be designed in a way that best suits
its purpose.

This is especially crucial for persistence. The approach of having one big
database for the whole \ms{} application is called an integration database and
is an anti-pattern for \mss{}. With polyglot persistence each \ms{} can use the
storage paradigm that is best suited for it. This eliminates the need for a
central persistence solution and therefore the single point of failure.

Polyglot programming allows development teams to work with the languages and
tools that they are used to. This greatly speeds up the development process.

\paragraph{Lightweight Containers}

Lightweight containers are the enabling technology for a \ms{} application.
Containers allow to build each \ms{} in its own confined environment. Containers
guarantee that the \ms{} runs with the exact same configuration despite
different environment (developers pc, build and test server, cloud provider).

Containers allow for easy deployment and scaling of a \ms{} application. They
also allow rolling updated meaning that a part of the application can be
exchanged without interrupting the operation of the application.

\paragraph{Decentralized Continuous delivery}

Continuous delivery is the ability to extend an existing \ms{} application which
is already in production. The main goal is to deliver these extension safely
quickly and regular. Decentralized in this regard means the absence of a central
artifact that has to be delivered every time the application changes.

\paragraph{DevOps}

DevOps are the glue between the development and the operation of a \ms{}
application. The idea is that these engineers are already part of the project
during the initial development of an application. This gives the DevOps of a
certain application a deep understanding of the technical requirements of the
application. This also allows to test the deployment process very early. When a
\ms{} application is in production the DevOps engineers have enough insight in
the application internals to be able co cope with most problems that arise.
A. Earnshaw published a blog-post that describes DevOps very
well\cite{earnshaw2013devops}.

\subsubsection{\ms{} Composition}

\subsubsection{\ms{} Deployment}

\subsubsection{\ms{} Development}

\section{Delimitations, Limitations, and Assumptions}




















