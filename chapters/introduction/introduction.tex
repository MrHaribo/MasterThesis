\chapter{Introduction}

\section{Purpose of the Study}

The main purpose of this thesis is to incorporate the two research areas \mss{}
and \ogs{}. Both areas have individually been the topic of intense research
lately \todo{Citation needed} but very little research exists on how to combine
the two.

In regard to the \mss{} domain this thesis serves as a base for discussion about
\ms{} applications. Specifically the development and operation a set of \mss{} is
explained in detail. Of particular interest is the topic of how to facilitate
the composition of \mss{} and how to deploy a \ms{} application in a modern could
environment.

This thesis also provides a proof of concept that it is possible to develop
\ogs{} using \mss{}. For this purpose a vertical slice prototype is provided to
showcase the necessary fragments that make up a working \og{} in the \ms{}
world. Furthermore this prototype serves as a simple development example of how
to reproduce the development process of \ogs{}. The prototype is intended to
live on after this thesis ends and will continuously improved in the future.

As a secondary objective the usability of the recently very popular
\todo{Citation needed} Procedural Content Generation (PCG) is also discussed in
this thesis.

\section{Theoretical framework}

To curtail the infinite amount of research problems that the topics \ogs{} and
\mss{} offer a theoretical framework can be used. Within the framework the
abstract research problems are translated to research questions that cover the
area of interest sufficiently. According to the research questions hypotheses
can be formulated. The verification of these hypotheses is the final goal of
this thesis.

\subsection{Research Problems and Research Questions}
\label{sub:problems}

\todo{Formulate according to template}

\subsubsection{Usability of a \ms{} for \ogs{}} 

\paragraph{Research Problem:} The usability of \ms{} suited to develop and
operate an \og{}.

\paragraph{Research Questions:}
\begin{itemize}
  \item Can an \og{} run in a \ms{} environment?
  \item Is a \ms{} influenced architecture suitable to design an \og{}?
  \item Is the added complexity during development tolerable?
  \item Do \mss{} have enough performance to drive a fast-paced \ogs{}? 
\end{itemize}

\subsubsection{Deployment and Operation}

\paragraph{Research Problem:} The deployment and operation of a \ms{}
application in a cloud cluster-environment.

\paragraph{Research Questions:}
\begin{itemize}
  \item Which steps are necessary to bring a \ms{} driven \og{} ``from code to
  the cloud''?
  \item How can the deployment process be automated?
  \item How well do \ogs{} run in a cluster-environment?
  \item How does a modern container engine assist in deploying and operating a
  \ms{} driven application?
\end{itemize}

\subsubsection{\ms{} Composition}
\paragraph{Research Problem:} The composition of a set of \mss{} to form a coherent
distributed application.

\paragraph{Research Questions:}
\begin{itemize}
  \item What degree of composition is necessary for a \ms{} application
  to work?
  \item Which of the common paradigms orchestration and choreography is suited
  better for \ms{} composition?
  \item Which middle-ware is most useful in providing \ms{} composition?
  \item How can multiple game features be developed in parallel in different
\mss{} while preserving the overall application behaviour?
  \item What problems are introduced by coupling game features loosely?
  \item How does the consistency vs. performance trade-off impact \ogs{}?
  \item What protocols help to reduce service coupling?
\end{itemize}

\subsubsection{\ms{} Development}
\paragraph{Research Problem:} The development process of a \ms{} application.

\paragraph{Research Questions:}

Development of a \ms{} application:
\begin{itemize}
  \item What separates \ms{} development from regular development?
  \item Which tools help with \ms{} development simpler?
\end{itemize}

\subsection{Hypotheses}
\label{sub:hypothesis}

The essence of the research problems can be condensed to a set of hypotheses
which correspond with the different research areas. All hypotheses are
verified in the course of this thesis to prove that \mss{} are suited to
build an \og{}. 

\subsubsection{\ogs{} and \mss{} Hypothesis}
It is possible to build an \og{} as a pure \ms{} application by
respecting all seven \ms{} tenets.

\subsubsection{Required Features Hypothesis}
A minimal set of features is required to build a distributed \og{}: Networking,
persistence, serialization, session management and game engine integration.

\subsubsection{Stability and Performance Hypothesis} 
Microservices allow to separate the performance critical real-time game
simulation in regards to computing, bandwidth and latency requirements from the
non time-critical backend functionality of an online game. This allows arbitrary
scaling.

\subsubsection{Composition Hypothesis}
Code Generation backed by a game meta model is enough information to compose a
set of \mss{} semantically to compound a rich \og{}.

\subsubsection{Deployment Hypothesis}
The deployment process of game a \ms{} application can be simplifies to an
extent that the process can be understood by reading instruction of the size of
one screen.

\subsubsection{Simple Development Hypothesis} 
Microservice can make the complicated process of developing online games simpler
by splitting up a complex game domain into small parts that can be developed
independently.

\subsubsection{Reproducibility Hypothesis} 
It is possible to completely prevent initial costs to kick of the development
process using only free/open-source technologies. This allows to reproduce the
development process anywhere at any time.

\section{Significance of the Study}

\mss{} are a very modern approach to realize a Service Oriented Architecture
(SOA). While SOA is not something new and has been in use for more then a decade
\todo{Citation needed} \mss{} are a cutting edge implementation approach to SOA
which has gained popularity only in the recent years. Therefore the theory and
references of how to actually develop and operate such a \ms{} environment are
rather sparse. This thesis servers as a complete reference for all relevant
aspects that have to be taken into account when an application (especially an
\og{}) is developed using \mss{}.

In regards to \ogs{} \mss{} have gained recent popularity. This is due to the
fact that large game development companies (>100 developers) prosecute \ogs{}
with million of player playing at the same time. For these games to scale the
traditional approach of running an \og{} as a monolithic application is not
sufficient. These large companies have large budgets at their disposal to
realize such an \og{}.

But this is not the case for smaller independent game development companies.
Independent companies are not constraint by founders and are therefor the main
driver for innovation in the game industry at the moment. But these  indy-teams don't
have the manpower to develop rich \ogs{} from scratch because the lack of
manpower and financial resources. Also AAA companies don't share their knowledge
about \og{} development to an extent that would allow indies to develop rich
\ogs{}.

Further \og{} development introduces the aspect of distribution within the game
application which is by definition a hard problem \todo{Citation needed}. There
is a lot of existing information on how to cope with asynchronism in game
development\todo{Cite: Gambetta}. However these references are mostly very low
level and leave a lot of responsibility to the developer. This added complexity
is whats holding back creative minds to develop rich \ogs{}. This thesis should
serve as a reference for these independent developers to gain a foothold in the
complex area of \og{} development.

\section{Definitions}

This thesis is aimed to be a direct reference for developing \ogs{} with \mss{}.
Because of this the thesis is of very technical nature. Most concepts developed
in this thesis have a reference implementation in the prototyped developed
during this thesis. 

This section clarifies all terminology that is used to define the concepts
developed in this thesis from a technical point of view.

\subsection{Design Science Methodology}

Design science offers the definition of a scientific framework that can be used
to formally define and describe real world research problems. Along with the
definition on how to conduct scientific research is also provides very useful
templates to formally frame research problems and research questions. The
research problems of this thesis are framed using the design science principles.
The paper Design Science, The Design Cycle \& Theoretical Frameworks
\cite{biedermann2016design_science} provides a good overview on the topic.

\subsection{Games and \ogs{}}
\label{sub:games}

Since this thesis is mainly aimed at readers interested in the \ms{} domain it
is mandatory to provide a reasonable introduction in games itself an which
technical requirements they introduce. This helps to frame influence that \ogs{}
can possibly have when built using \mss{}.

\subsubsection{Video Games}

A video game is simply a game played on a digital device e.g. PC, smartphone, or
gaming consoles. The technical details how all of these games are developed
varies greatly depending on various factors like genres, platforms, culture and
so on. Since this thesis does not make any restrictions on the kind of game
under development a common basis for all games must be established. In this
regard the classical Model-View-Control pattern can be used to identify the
logical artifacts that make up a game: 

\begin{itemize}
  \item \textbf{Model:} The game model artifact holds the game state.
  \item \textbf{View:} The game presentation artifact presents the game state to
  the player.
  \item \textbf{Control:} The game simulation artifact progressed the game
  state and is responsible to accept player input.
\end{itemize}

\paragraph{Game Simulation}

The game simulation can be seen as a logical abstraction of a game. The
simulation is responsible to update the state of all relevant game objects to
progress the state of the game as a whole. In most games the game simulation is
realized with a physics engine along with code that steers the simulation.

\paragraph{Game Presentation}

The game presentation is responsible render the game state on the player
device's screen. Changes in the game state must be made visible by the game
presentation as soon as possible.

The game simulation is usually tightly coupled with the game presentation. This
is due to the nature of the most basic graphics libraries like DirectX or OpenGL
which are foundation of most video games. These graphic libraries typically have
one main render loop. Within this loop the developer gets a chance to update
every game object before it is drawn to the screen. As a consequence the game
simulation cannot be completely separated from the presentation process. More
information on graphics libraries can be found in the book Real-Time
Rendering\cite{RTR3}. Furthermore the web-page of the book provides a
comprehensive selection on related literature and technical examples.

\paragraph{Game Model}

The game model consists of a meta model containing a set of object types and an
instantiation of this meta model which represents the game state. The game
simulation operates upon the game state to progress the game. Static data
like for example audiovisual information for the game presentation is directly
stored in the meta model and can be referenced by the game state.

\paragraph{Game Engines}
All the artifacts of a game as described in the previous three sections are
fairly low level. To relieve the developer from these low level tasks usually
game engines are used. These game engines come with comprehensive editors, tools
and libraries that abstract the complex low level functionality. This allows the
developer to focus the effort on the core parts of the game. 

\subsubsection{\ogs{}}
An \og{} can be seen as an extension to a traditional video game. In addition to
the audiovisual representation the player not only interacts with the game
simulation but also with other players playing at the same time at another
location. But in practice the added asynchronism forces a completely different
application design in comparison to traditional single-player games.

\paragraph{Simple \ogs{}}

Simple \ogs{} are single-player games with added multi-player features.
In simple \ogs{} players are responsible to set up game's multi-player
environment. These can be client-server or peer-to-peer scenarios. In these
environments the players have full control over the game rules.

Usually simple games are of small scale and are played in confined game
sessions. The state of the game session is stored locally on the client.
Examples of such simple games are for example Quake, Age of Empires, or Diablo
2. Lately it has become popular for simple games to provide a matchmaking
service that helps players to find each other for game sessions. This
matchmaking functionality is responsible to initiate the game session on all
clients but does not interfere in a running game session meaning there is no
centralized rule enforcement system in place. Cheating clients are a common
problem for this type of games.

\paragraph{Rich \ogs{}}

Rich \ogs{} take the control over the game environment away from the player.
This means that the game is simulated on a server environment meaning that the
game client is only responsible for the presentation of the game and for sending
inputs to the server but not for simulating the game. In this setup the game
state is persisted on the server side. The persistence of the game state in this
fashion allows for a set of features which really separate \ogs{} from simple
online or offline video games.

Most noticeable is the feature of virtual property. In rich \ogs{} it is usually
possible to gain an advantage when it is player a lot. This gives the player a
sense of power and the motivation to play the game for longer. This can be
compared to the satisfaction that is triggers when a person receives a like on a
social media platform.

Rich \ogs{} are also very comfortable for the players. The players only need to
download the game client to play the game.

\subsection{Procedural Content Generation}

Procedural Content Generation (PCG) has always been an integral part of game
development and has gained recent popularity because of prominent games that
make extensive use of PCG. Some examples are Minecraft, Terraria, No Mans Sky to
only name a few.

PCG is the process of automatically generating game content. A canonical
example in this regard is vegetation generation. The developer only needs to
supply certain parameters like for example color distribution and branching
factor. The game simulation then 

\subsection{\mss{}}

Microservices are an implementation approach for a service-oriented
architecture\todo{Cite ZIO}. In SOA an application is split into logical units
that each solve one specific task. A problem of traditional SOA is that these
individual services are coupled using a service bus which contains a large
amount of domain knowledge which is used to allow communications between
services. \mss{} reverse this principal and use the smart endpoints - dumb pipes
paradigm. This makes the service bus obsolete. As a result the whole
application is more robust to changes because there is no central processing
unit exposed as a single point of failure.

\subsubsection{\ms{} Tenets}

In the article Microservices tenets: Agile approach to service development and
deployment O.Zimmermann provides seven \ms{} tenets to describe the properties
of \ms{} applications. According to the tenets a correlation between game
specific requirements and \ogs{} can be made. In the course of this thesis the
\ms{} tenets will be used as an indicator to show that \mss{} are suitable for
\og{} applications.

The remainder of this section will give a brief overview over all seven tenets.

\paragraph{Fine-grained Interfaces and Single Responsibility}

Every \ms{} should offer all of its functionality in the form of a fine grained
interface that decouples the service implementation from its interface. This
interface is usually a REST/HTTP and is accessible via a reverse proxy. Each
\ms{} should only have one responsibility in regards to the domain. This allows
services to be deployed, changed, replaced and scaled independently.

\paragraph{Domain-Driven-Design (DDD)}

The responsibility of a \ms{} should be derived from the domain concept. Each
service is dedicated to exactly one aspect of the domain. If this aspect is very
extensive it can lead to a large \ms{} which is not desirable. This can be an
indicator that the granularity of the services might be wrong. Granularity is
the most challenging part of DDD\cite{millett2015patterns}.

\paragraph{IDEAL}

The IDEAL tenet is a collection of cloud patterns. These patterns to partially
overlap with several other tenets like single responsibility or decentralized
continuous delivers. None the less this tenet is is a great indicator to
validate that an application respects the major cloud principals. C. Fehling et
al. provides a good overview over the  IDEAL Cloud Application Properties
summarized in this section\cite{fehling2015cloud}.

\subparagraph{Isolated State}
A \ms{} should be stateless meaning that request that the \ms{} fulfils should
be completely confined in itself. This means that \mss{} are not allowed to
store date in-memory between requests. Instead the state should be persisted in
a data storage provided by the cloud e.g. another \ms{}.

\subparagraph{Distribution}
To allow an application to scale, its functionality is spread out among several
different \mss{}. These shards are then deployed in cloud environments which are
large distributed system themselves. \ms{} applications are a natural match for
the distributed nature of cloud environments.

\subparagraph{Elasticity}
Elasticity inquires that the application can be scaled during operation. When
the need of scaling arises it must be possible to add and remove \mss{} without
affecting the stability of the whole system.

\subparagraph{Automated Management}
In order to quickly react to scaling demands or to recover from failure the
management approach to these scenarios should be fully automated.

\subparagraph{Loose Coupling}

The dependencies among \mss{} should be reduced as much as possible. It is not
feasible to reduce dependencies to zero because without any dependencies the
application is not able to work as a whole unit. If the amount of dependencies
is manageable the impact of adding and removing new functionality can be kept
to a minimum.

\paragraph{Polyglot Programming and Persistence}

The polyglot tenet is the main driver when it comes to \ms{} confinement. It
states that a \ms{} has no restriction on storage paradigms and implementation
details. As a consequence each \ms{} can be designed in a way that best suits
its purpose.

This is especially crucial for persistence. The approach of having one big
database for the whole \ms{} application is called an integration database and
is an anti-pattern for \mss{}. With polyglot persistence each \ms{} can use the
storage paradigm that is best suited for it. This eliminates the need for a
central persistence solution and therefore the single point of failure.

Polyglot programming allows development teams to work with the languages and
tools that they are used to. This greatly speeds up the development process.

\paragraph{Lightweight Containers}

Lightweight containers are the enabling technology for a \ms{} application.
Containers allow to build each \ms{} in its own confined environment. Containers
guarantee that the \ms{} runs with the exact same configuration despite
different environment (developers pc, build and test server, cloud provider).

Containers allow for easy deployment and scaling of a \ms{} application. They
also allow rolling updated meaning that a part of the application can be
exchanged without interrupting the operation of the application.

\paragraph{Decentralized Continuous Delivery}

Continuous delivery is the ability to extend an existing \ms{} application which
is already in production. The main goal is to deliver these extension safely
quickly and regular. Decentralized in this regard means the absence of a central
artifact that has to be delivered every time the application changes.

\paragraph{DevOps}

DevOps are the glue between the development and the operation of a \ms{}
application. The idea is that these engineers are already part of the project
during the initial development of an application. This gives the DevOps of a
certain application a deep understanding of the technical requirements of the
application. This also allows to test the deployment process very early. When a
\ms{} application is in production the DevOps engineers have enough insight in
the application internals to be able co cope with most problems that arise.
A. Earnshaw published a blog-post that describes DevOps very
well\cite{earnshaw2013devops}.

\subsubsection{\ms{} Composition}
\label{subsub:composition}

\ms{} composition is a very wide term and therefore need to be further
specified. For this purpose composition can be split into the two sub topics:
Physical composition and logical composition.

For \ms{} composition is it always possible to categorize a solution according
to the composition paradigms: Orchestration and Choreography. Orchestration
states that a set of \mss{} is composed by a central intelligence unit which is
responsible to keep the application healthy. Choreography implies that there is
no central intelligence and the cluster of \mss{} as a whole is responsible to
guarantee the stability of the application.

\paragraph{Physical Composition}

Physical composition is the discipline to bring a set of \mss{} onto a
physical computing environment, usually the cloud. The the case of the cloud the
term physical is understood as the appropriation of computing, memory, disc
space and networking capabilities.

Physical composition is usually enabled using composition engines like for
example docker-compose, docker-swarm, Apache Mesos or Kubernetes. The majority
of the composition engine use an orchestration approach. 

\paragraph{Logical Composition}

Logical composition is the aspect of how a set of confined \ms{} is working
together to solve to goal of the application as a whole. The logical composition
cannot be automated and is therefore a task that the developers of an
applications have to cope themselves. 

Logical composition of a \ms{} application has two major requirements that must
be satisfied. The services have to know how to find each other and the services
must be aware of the communication semantics. 

Usually the logical composition is realized with an RESTful API description that
can be accessed via a HTTP. Especially for regular web applications a vast
choice of middle-ware is available. For example Swagger, JaxRS, JSON API, and
API Blueprint just to name a few.

The composition paradigm that is used for logical composition is very dependent
on the type of application under development. In an orchestration solution there
would be one central point where \mss{} could look up crucial information like
message formats and service locations. In an choreography solution the this
information would be distributed among all services to form a mesh of
information about the application cluster. In this case information can be
requested from any \ms{} in the system.

\subsubsection{\ms{} Deployment}

\ms{} deployment comprise the whole process that is necessary to bring an application
from the development stage into production. This process includes several steps: 

\begin{itemize}
  \item Bring the application code along with eventual dependencies into the
  service containers.
  \item Upload the application containers to the cloud
  \item Prepare the application on the server side
  \item Start the application as a whole by starting all service containers
  \item Scale the application according to operational needs
  \item Set up backup and recovery solutions for the application
  \item Deploy monitoring solution to keep track of the application
\end{itemize}

While most of these processes can be automated in the long term it requires a
lot of effort to bring these deployment automation practices into place.

\subsubsection{\ms{} Development}

\ms{} development consists of the whole process of designing an application
using an approach suited for \ms{}, writing the code for the application, manage
the collaboration of different developers on the same project.

\section{Delimitations, Limitations, and Assumptions}

Several limitations have a big influence on this thesis. 

\subsection{\ms{} are Developed by Teams}
One of the greatest advantages of \mss{} is that they allow to split the
development on a complex application into small shards that can be developed by
small flexible individual teams. This aspect of \mss{} can only be analyzed
conceptually because this thesis is a one-man project.

\subsection{Zero Budget}
\label{sub:zero_buget}
Cloud service providers like Amazon or Google offer a free tier to evaluate
their cloud capabilities. But even this free tiers of subscription require a
valid credit card for the case that the free quota is exceeded. This is a risk
that the HSR did not want to bear. As a consequence the testing environment for
the prototype developed in this thesis is a virtual server provided by HSR. This
setup makes it difficult to finalize the process of game development with \mss{}
because in a real world example companies would rely on cloud service provider
to have a stable cloud computing environment. It is also a pity because both
Google and Amazon just recently released dedicated solutions for how to deploy
\ogs{} on their environments. Evaluating these solutions would have been a very
interesting topic.

\subsection{Limitations introduced by games}
As explained in \autoref{sub:games} the way games are built itself is a huge
limitations on the design of a \og{} application. To analyze all aspects of game
development in detail is out of scope for this thesis. Instead this thesis takes
a more general approach by viewing the rendering any physics engine details as a
black box. This allows to focus on the logical parts of \og{} development, the
game model and the game simulation which is most relevant in regards to a \ms{}
realization.

\subsection{Time Constraint}
In the original plan for this thesis the topic Procedural Content Generation
(PCG) was intended to be research very detailed. But since the topics:
Deployment and composition required a lot more effort then anticipated, the time
budget for PCG shrunk close to zero. Because of this PCG will only receive minor
attention in this thesis. 

Another aspect that intensified this problem is the fact that this thesis is the
third out out a series of three and a lot of work was necessary to conclude the
project as a whole.

\subsection{Delimitation}

There are also some delimitations (limitations that can be lifted) that became
apparent during this thesis:\\

Games are usually developed using Microsoft Windows. But cloud developers tend
to use mainly Linux tools. Because of this many tools are cumbersome to use on
Windows platforms and therefore greatly hinder the development process. It is a
side-goal of this thesis to facilitate the whole process on Windows. 



















