\section{Technology Stack}

The feature hypothesis (\autoref{sub:hypothesis}) states that networking,
persistence, serialization, session management and game engine integration are
necessary to build a fully functional \og{}. These essential features are
mandatory to drive an \og{}.

In addition to this core technology, supplementary technologies are needed to
help fulfill the deployment and the simple development hypothesis
(\autoref{sub:hypothesis}). These technologies are: Container engine,
composition engine, continuous integration solution, source control system, and
interactive development environment (IDE).

The rest of this section describes each technology and states advantages and
disadvantages along with the arguments which are decisive for the composition
of the technology stack.

\subsection{Core Technologies}

The core technologies have mostly been defined and tested in the prior two
project thesis. This section gives a short summary on the chosen technologies.

\subsubsection{Networking}

\begin{wrapfigure}{r}{4cm}
    \includegraphics[width=4cm]{images/dependencies/activemq}
\end{wrapfigure}

\textbf{ActiveMQ} is a popular message broker. A message broker buffers
messages and delivers them as soon as a receiver is available. This allows for a
robust persistent messaging. Message brokers have been evaluated during
project thesis one. ActiveMQ is the networking foundation of MicroNet and
has proven to be very stable. ActiveMQ provides a Java JMS library which
provides a way to easily integrate ActiveMQ in Java applications.

ActiveMQ is available on Docker Hub as a Docker image and can therefore
be integrated into a \ms{} application very easily using a composition engine.


\subsubsection{Persistence}

\begin{wrapfigure}{r}{4cm}
 	\hspace*{0.4cm}
    \includegraphics[width=4cm]{images/dependencies/PostgreSQL}
\end{wrapfigure}

\textbf{PostgreSQL} is a very mature open source relational database. It is
available on all major platforms which allows for comfortable testing and
deployment. Since version 9.2 PostgreSQL supports the Json data-type which makes
it trivial to control the data flow from the network to the database.

PostgreSQL is also available on Docker hub and can therefore be integrated
quickly. For production purposes a native installation of PostgreSQL is
suggested to provide the needed stability as explained in
\autoref{sub:database_solutions}.\\ 


\begin{wrapfigure}{r}{4cm}
    \includegraphics[width=4cm]{images/dependencies/couchbase}
\end{wrapfigure}

\noindent
\textbf{Couchbase} is a NoSQL database realized as a Json document store. The
Json affinity of Couchbase integrates very well with the the technology stack.
Couchbase has its own query language called N1QL which allows aggregated
querries between multiple documents. Also access on sub-document level is
possible to allow fine grained data access.

Couchbase can run in a cluster and maintains a quorum on each documents to
provide eventual consistency on writes. The cluster functionality can be used to
scale the database system. Couchbase also provides timeouts of documents which
can be used to imitate \textit{session store} behaviour. This neglects the need
for a distributed caching system like Redis for example.

Even if Couchbase exists as a Docker image it is advised to install
Coutchbase native for production for the reasons explained in
\autoref{sub:database_solutions}.
    
\subsubsection{Serialization}

\begin{wrapfigure}{r}{4cm}
    \includegraphics[width=4cm]{images/dependencies/google-gson}
\end{wrapfigure}

\textbf{Gson} from Google offers a very convenient out-of-the-box approach to
serialize Java objects to Json strings and vice versa. An advantage of Gson is that
also supports generic collections like hash-maps.

The main advantage of Gson is it's simplicity. The simplicity goes to the cost
of performance especially for the de-serialization of json strings.
Because of this reason simple Gson serialization is only usable in areas where a
performance hit does not influence the application behaviour.

\subsubsection{Game Engine}

\begin{wrapfigure}{r}{4cm}
    \includegraphics[width=4cm]{images/dependencies/Unity3D}
\end{wrapfigure}
    
\textbf{Unity3D} is very popular among independent developers because it has no
initial financial barrier. Unity is very well documented and has a very
healthy community to provide aid for development problems.

Unity3D provides a rich editor that allows to prototype games quickly. It
also offers a rich C\# API which allows to write any imaginable game logic. 

For this thesis it is in particular interesting how well the combination of
C\# game logic and Java back-end logic works in regards to the \ms{} tenet
polyglot programming.
    


\subsection{Supplementary Technologies}

The supplementary technologies have been under intense evaluation during this
thesis. The result of this evaluation is a set of augmenting technologies which
work well together, are easy to learn, and are open source or have a community
edition (free of charge and maintained by the community).

\subsubsection{Container Engine}

\begin{wrapfigure}{r}{4cm}
	\vspace*{-0.5cm} \hspace*{0.2cm}
    \includegraphics[width=3cm]{images/dependencies/docker}
\end{wrapfigure}

\textbf{Docker} has already been mentioned several times during this document.
The essence about Docker is that it is an enabler technology. This is because all
other composition and container technologies support Docker in some way. This
aspect makes the Docker Engine a reliable intermediate layer between the actual
hardware and the application running on it.


\subsubsection{Composition Engine}

\begin{wrapfigure}{r}{4cm}
	\vspace*{-0.5cm} \hspace*{0.4cm}
    \includegraphics[width=2.4cm]{images/dependencies/docker-compose}
\end{wrapfigure}

\textbf{Docker-compose} is basically only a CLI application which translates a
docker-compose file into a set of docker commands which are executed
sequentially. The result is a containerized application running on a single
host. Docker-compose is very helpful to quickly deploy a \ms{} application
stack locally. The docker-compose format also provides the basis to deploy a
composed application in the cloud using docker-swarm.\\

\newpage

\begin{wrapfigure}{r}{4cm}
	\hspace*{0.4cm}
    \includegraphics[width=3.3cm]{images/dependencies/docker-swarm}
\end{wrapfigure}

\textbf{Docker-swarm} allows to run containerized applications on a cluster of
docker machines. A docker machine is simply a host running a docker engine. Docker
swarm allows to set the services of an application individually using the docker
stack CLI or by deploying the whole application stack using a docker-compose
file. Docker swarm offers multiple scheduling strategies which distribute the
containers among the available docker machines.

The major advantage of docker-swarm is its simplicity. Only a few commands are
needed to control the cluster and therefore docker-swarm is easy to understand.
Also since it is the native Docker composition technology it is a natural match
for containerized Docker applications.

One noticeable disadvantage is the lack of several convenience features like
a build-in dashboard or auto-scaling support. This is not a big concern
since many third party dashboard tools like for example Grafana are available
and auto-scaling can be added with a little bit of implementation effort. 

\subsubsection{Continuous Integration}

Continuous integration is generally a party of every software project and \og{}
are no exception. In this thesis the continuous integration process is examined
up to the point where all individual steps of the process are defined. From here
a central build system like Jenkins can take over an unify the whole build
process but this aspect is not covered in this thesis.\\

\begin{wrapfigure}{r}{4cm}
    \includegraphics[width=4cm]{images/dependencies/maven}
\end{wrapfigure}

\textbf{Maven} provides a convenient way to define the build process of Java
applications. For the game back-end services which are mainly written in Java
this is a perfect match to define the build process.

Maven also works very well in conjunction with Docker. A dedicated Maven Docker
image allows for easily integrate the Java build process into the Docker build
process by executing the Maven build inside the target container. This approach
removes the need of any local Java or Maven installation. 

The drawback of the completely in-container Maven build is it's performance.
Maven downloads ``the whole Internet'' into every container to build the
application. This is not useful during development where short build times are
mandatory. To cope with this problem the Maven build can be conducted on the
host system and only the binaries are send to the Docker daemon for the
container build. This makes the build process much faster and has no real
disadvantage because the process can be reproduced exactly on the build system
and therefor also speeds up automated builds.

Maven is also very useful to preserve a consistent versioning of \mss{}. The
game application stack can be described using a master .pom file containing
the required versions of all services. The master .pom file can be updated to
introduce a new version of any service. The continuous integration process can
be triggered at this point to perform a rolling update of the currently
deployed application stack.\\
	
\begin{wrapfigure}{r}{4cm}
    \includegraphics[width=4cm]{images/dependencies/github}
\end{wrapfigure}

\textbf{Git} is the \textit{Source Control System} that builds the foundation
for the version control. Git works great to share Maven projects which in turn
allows to reproduce the build process locally and also on a build server.

Github is used to provide any needed dependency used for the build process.
MicroNet is also published via Github.

\subsubsection{Interactive Development Environment (IDE)}

IDE is a wide term for a tool that simplifies the development process of a
software program. Usually it provides comprehensive tools that assist in writing
the source code of an application.\\

\begin{wrapfigure}{r}{4cm}
    \includegraphics[width=4cm]{images/dependencies/eclipse}
\end{wrapfigure}

\textbf{Eclipse provides} a very solid IDE to develop Java projects. The plug-in
development environment of Eclipse allows to customize the IDE to an arbitrary
extent. This aspect is especially useful because in regards to \mss{} because
nearly no \ms{} development specific tools are available on the market. Also
Eclipse provides a number of very useful plug-ins for Java development.

The \textit{Docker Tools} for Eclipse are a visual explorer  for Docker images
and containers. It allows to quickly start, stop, build and remove containers
without having to bother with console commands.

\textit{Launch Groups} is a plug-in contributed by Eclipse CDT (C++ development
plug-in for Eclipse). It is very useful to directly run or debug multiple
applications at once. This allows to quickly bring up or terminate the whole
application stack for testing purposes. Although CDT is required for Launch
Groups it does not interfere with Java development.































